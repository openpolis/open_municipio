## -*- mode: python -*-
"""
Starter fabfile for deploying a Django-powered web application.

All the settings marked with ``CHANGEME`` MUST be changed to reflect
project-specific setup.  Other settings MAY be changed, but their values should be
generic enough to provide for sensible defaults.

"""

import os

from fabric.api import *
from fabric.contrib.project import rsync_project
from fabric.contrib import files, console
from fabric import utils
from fabric.context_managers import cd, lcd, settings, hide

# Python interpreter executable to use on virtualenv creation
PYTHON_BIN = 'python2.6'  ## CHANGEME!
PYTHON_PREFIX = '' # e.g. ``/usr``, ``/usr/local``; leave empty for default.
PYTHON_FULL_PATH = "%s/bin/%s" % (PYTHON_PREFIX, PYTHON_BIN) if PYTHON_PREFIX else PYTHON_BIN

# exclude patterns for ``rsync`` invocations
RSYNC_EXCLUDE = ( 
    ##CHANGEME!
    '*~',
    '.git',
    '.gitignore',
    '*.pyc',
    '*.sample',
    '*.db',
    'docs/',
    '*.markdown',
    'fabfile.py',
    'bootstrap.py',
    'apache/*',
    'open_municipio/settings_*.py',
    'open_municipio/urls_*.py',
    'open_municipio/sitestatic',
)

## TODO: these constants should be read from an external configuration file
# the name of the project managed by this fabfile
PROJECT_NAME = 'open_municipio' 
# a unique identifier for this web application instance
# usually is set to the primary domain from which the web application is accessed
APP_DOMAIN = 'www.example.com' 
# filesystem location of project's files on the local machine
LOCAL_PROJECT_ROOT = '/local/path/to/open_municipio'

env.project = PROJECT_NAME
env.app_domain = APP_DOMAIN

## Environment-specific setup
def staging():
    """ Use staging environment on remote host"""
    env.environment = 'staging'
    ## TODO: these constants should be read from an external configuration file
    # the system user (on the server machine) used for managing websites
    WEB_USER = 'webuser' ##CHANGEME!
    # the parent directory of domain-specific directories (on the server machine) 
    WEB_ROOT = os.path.join('/home', WEB_USER, 'websites') 
    # the root directory for domain-specific files (on the server machine)
    DOMAIN_ROOT = os.path.join(WEB_ROOT, env.app_domain) 
    # the root directory of application-specific Python virtual environment (on the server machine)
    VIRTUALENV_ROOT = os.path.join(DOMAIN_ROOT, 'private', 'venv') 
    # the root directory for project-specific files (on the server machine)
    PROJECT_ROOT = os.path.join(DOMAIN_ROOT, 'private', env.project) 
    # the root directory for application-specific Python code (on the server machine)
    CODE_ROOT = os.path.join(PROJECT_ROOT, env.project) ##CHANGEME!
    # import path of Django settings file for the staging environment
    DJANGO_SETTINGS_MODULE = '%(project)s.settings_staging' % env 
    # Directory where static files should be collected.  This MUST equal the value
    # of ``STATIC_ROOT`` attribute of the Django settings module used on the server.
    STATIC_ROOT =  os.path.join(DOMAIN_ROOT, 'public', 'static') ## CHANGEME!
    ## set up Fabric global environment dictionary
    env.web_user = WEB_USER
    env.web_root = WEB_ROOT
    env.domain_root = DOMAIN_ROOT
    env.virtualenv_root = VIRTUALENV_ROOT
    env.project_root = PROJECT_ROOT
    env.code_root = CODE_ROOT
    env.settings = DJANGO_SETTINGS_MODULE
    env.static_root = STATIC_ROOT
    
    env.roledefs = {
    'web': ['webuser@www.example.com'],
    'db': ['dbuser@db.example.com'],
    }


def production():
    """ Use production environment on remote host"""
    env.environment = 'production'
    utils.abort('Production deployment not yet implemented.')


## Webserver management

def webserver_reload():    
    """Reload the webserver on remote host"""
    sudo('/etc/init.d/apache2 reload')

def webserver_start():    
    """Start the webserver on remote host"""
    sudo('/etc/init.d/apache2 start')

def webserver_stop():    
    """Restart the webserver on remote host"""
    sudo('/etc/init.d/apache2 stop')

def webserver_restart():    
    """Restart the webserver on remote host"""
    sudo('/etc/init.d/apache2 restart')

def webserver_enable_site(site_name):
    """Enable a webserver virtualhost"""
    sudo('a2ensite %s' % site_name)

def webserver_disable_site(site_name):
    """Disable a webserver virtualhost"""
    sudo('a2dissite %s' % site_name)

def upload_webserver_conf():
    """Upload webserver configuration to remote host"""
    require('environment', provided_by=('staging', 'production'))
    ## upload custom Apache directives
    source = os.path.join(LOCAL_PROJECT_ROOT, 'apache', 'httpd.conf.%(environment)s' % env)
    with cd('/etc/apache2'):
        dest = 'httpd.conf'
        put(source, dest, use_sudo=True, mode=0644)
        sudo('chown root:root %s' % dest)
    ## upload Virtual Host configuration
    source = os.path.join(LOCAL_PROJECT_ROOT, 'apache', 'vhost.conf.%(environment)s' % env)
    with cd('/etc/apache2/sites-available'):
        dest = env.app_domain
        put(source, dest, use_sudo=True, mode=0644)
        sudo('chown root:root %s' % dest)
  
def update_webserver_conf():
    """Update webserver configuration on remote host """
    upload_webserver_conf()
    webserver_enable_site(env.app_domain)
    webserver_restart()

def touch_WSGI_script():
    """ Touch WSGI file to trigger code reload """
    require('project_root', provided_by=('staging', 'production'))
    apache_dir = os.path.join(env.project_root, 'apache')
    with cd(apache_dir):
        run('touch django.wsgi')

def clear_logs():
    """
    Clear website-specific logs.
    """
    require('domain_root', provided_by=('staging', 'production'))
    with cd(env.domain_root):
        run('rm -f log/*')
    

## Virtual environment management

def create_virtualenv():
    """Create a virtualenv on remote host"""
    require('virtualenv_root', provided_by=('staging', 'production'))
    args = '--clear --python=%s --no-site-packages' % PYTHON_FULL_PATH
    run('virtualenv %s %s' % (args, env.virtualenv_root))

def ensure_virtualenv():
    """Check if a project-specific virtualenv already exists; if not, create it."""
    require('virtualenv_root', provided_by=('staging', 'production'))
    if files.exists(os.path.join(env.virtualenv_root, 'bin', 'python')):
        return
    else:
        create_virtualenv()

def virtualenv(venv_root):
    """
    This context manager is intended for specifying a virtualenv to use.
    
    Note that it should be used only for selecting a virtualenv different from
    the project-specific one (available from ``env.virtualenv_root``)
    """
    return settings(virtualenv_root=venv_root)


def run_venv(command, **kwargs):
    """
    Run a command (via ``fabric.api.run``) within a given virtualenv context 
    (to be specified either via ``env.virtualenv_root`` or the ``virtualenv`` 
    context manager)
    """
    require('virtualenv_root', provided_by=('staging', 'production'))
    env.activation_script = os.path.join(env.virtualenv_root, 'bin/activate')
    cmd = ['source %(activation_script)s' % env]
    cmd += ['export PYTHONPATH=%(project_root)s:$PYTHONPATH' % env ] # configure PYTHONPATH
    cmd += [command] # shell command to be run within this virtualenv
    run(' && '.join(cmd), **kwargs)


def update_requirements():
    """
    Update external dependencies on remote host.
    """
    require('project_root', provided_by=('staging', 'production'))
    ensure_virtualenv()
    requirements_dir = os.path.join(env.project_root, 'requirements')
    # TODO: generalize to multiple requirement files
    with cd(requirements_dir):
        pip_executable = os.path.join(env.virtualenv_root, 'bin', 'pip')              
        cmd = [pip_executable] # use pip version provided by virtualenv              
        cmd += ['install']
        cmd += ['--upgrade'] # upgrade already installed packages
        cmd += ['--requirement %s' % os.path.join(requirements_dir, 'main.txt')] # specify a requirement file
        run(' '.join(cmd))

## Application code management

def copy_website_skeleton():
    """
    Create a skeleton directory tree for the new website.

    Include setup of suitable filesystem permissions.
    """
    require('web_root', 'app_domain', provided_by=('staging', 'production'))
    # FIXME: skeleton should be created programmatically for increased portability
    with cd(env.web_root):
        if files.exists(env.app_domain):
            utils.abort("Directory %s already exists on the remote machine" % os.path.join(env.web_root, env.app_domain))
        run('cp -a skeleton %(app_domain)s' % env) 

def update_code():
    """Transfer application code to remote host"""
    require('project_root', 'code_root', provided_by=('staging', 'production'))
    if env.environment == 'production':
        if not console.confirm('Are you sure you want to deploy to the production server(s)?',
                               default=False):
            utils.abort('Production deployment aborted.')
    # defaults rsync options:
    # -pthrvz
    # -p preserve permissions
    # -t preserve times
    # -h output numbers in a human-readable format
    # -r recurse into directories
    # -v increase verbosity
    # -z compress file data during the transfer
    extra_opts = '--omit-dir-times'
    rsync_project(
        remote_dir = env.project_root,
        local_dir = LOCAL_PROJECT_ROOT + os.path.sep,
        exclude=RSYNC_EXCLUDE,
        delete=True,
        extra_opts=extra_opts,
    )
    
    with lcd(os.path.join(LOCAL_PROJECT_ROOT, env.project)):
        with cd(env.code_root):
            # update Django settings module
            settings_file = 'settings_%(environment)s.py' % env
            put(settings_file, settings_file, mode=0644)
            # update Django main URLconf module
            urls_file = 'urls_%(environment)s.py' % env        
            put(urls_file, urls_file, mode=0644)

    with lcd(os.path.join(LOCAL_PROJECT_ROOT, 'apache')):
        with cd(os.path.join(env.project_root, 'apache')):
            source = '%(environment)s.wsgi' % env
            dest = 'django.wsgi'
            put(source, dest, mode=0644)

    # trigger code reloading
    touch_WSGI_script()


## Static files management

def setup_static_files():
    require('static_root','virtualenv_root', provided_by=('staging', 'production'))
    # safety checks
    assert env.static_root.strip() != '' and env.static_root.strip() != '/'
    # Before Django 1.4 we don't have the ``--clear`` option to ``collectstatic``
    run('rm -rf %(static_root)s/*' % env)
    run_venv('django-admin.py collectstatic -v 0 --noinput --settings=%(settings)s' % env)


## Database management
@roles('db')
def create_database():
    """
    Create the application's database on the server machine.
    """
    raise NotImplementedError

@roles('db')
def drop_database():
    """
    Delete the application's database on the server machine.
    """
    require('code_root', provided_by=('staging', 'production'))
    with cd(env.code_root):
        if files.exists('sqlite.db'):
            run('rm -f sqlite.db')

@roles('db')
def remote_sync_db():
    """
    Sync the application's database on the server machine.
    """
    require('settings', 'virtualenv_root', provided_by=('staging', 'production'))
    run_venv('django-admin.py syncdb --noinput --settings=%(settings)s' % env)
    
@roles('db')
def update_database():
    """
    Update remote database (including South migrations, if any).
    """
    require('settings','code_root', provided_by=('staging', 'production'))
    drop_database()
    run_venv('django-admin.py syncdb --all --noinput --settings=%(settings)s' % env)
    # if getattr(env, 'initial_deploy', False):
    #     run_venv('django-admin.py syncdb --all --noinput --settings=%(settings)s' % env)
    #     run_venv('django-admin.py migrate --fake --noinput --settings=%(settings)s' % env)
    # else:
    #     run_venv('django-admin.py syncdb --all --noinput --settings=%(settings)s' % env)
    #     run_venv('django-admin.py migrate --noinput --settings=%(settings)s' % env)


## Macro-tasks
@roles('web')
def initial_deploy():
    """
    Deploy the web application to remote server(s) **for the first time**

    The first deployment procedure may differ from subsequent ones,
    since some initialization tasks have to be performed only once.

    Some examples:
    * fake South migrations
    * ..
    """
    env.initial_deploy = True
    deploy()        

@roles('web')
def deploy():
    """
    Deploy the web application to remote server(s)
    """
    require('environment', provided_by=('staging', 'production'))
    ## TODO: early initialization steps go here  
    if env.initial_deploy:
        copy_website_skeleton()

    with settings(warn_only=True):
        webserver_stop()

    update_code()
    update_requirements()
    update_database()
    setup_static_files()
    adjust_permissions()
    clear_logs()

    webserver_start()


def adjust_permissions():
    """
    Adjust filesystem permissions after completing the deployment process.
    """
    require('web_user', 'domain_root', 'code_root', provided_by=('staging', 'production'))
    sudo('chown -R %(web_user)s:www-data %(domain_root)s' % env)
    ## Only needed for SQLite DBs
    # SQLite need write access to the folder containing the DB file
    sudo('chmod g+w %(code_root)s' % env)
    # SQLite need write access to the DB file itself
    db_file = os.path.join(env.code_root, 'sqlite.db')
    sudo('chmod g+w %s' % db_file)


